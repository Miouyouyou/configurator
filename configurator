#!/usr/bin/env python3

import logging
from pathlib import Path
import os
import subprocess
import sys

# TODO Review the architecture
# Currently, the packaging and the execution folder architectures
# are mixed together.
# Try to decouple them.

class Configurator:
    # FIXME Parse these information from configuration files
    REQUIRED_FILES_PATHS=['module', 'DESC']

    # TODO Put such functions and setup into libraries

    def __init__(self, architecture, distribution, modules_path):
        main_logger = logging.getLogger('armbian-configurator')
        main_logger.setLevel(logging.DEBUG)
        main_logger.addHandler(logging.StreamHandler())
        self.main_logger  = main_logger
        self.modules_path = Path(modules_path)
        self.architecture = architecture
        self.distribution = distribution

        self.list_modules_renewed(self.modules_path)

    def list_dirs(self, from_dir=".", containing_files=[]) -> list:
        entries = None
        try:
            entries = os.scandir(from_dir)
        except:
            return []
        dirs = [Path(entry.path) for entry in entries if entry.is_dir()]

        valid_dirs = []
        for directory in dirs:
            all_files_present = True
            for required_file in containing_files:
                required_file_path = Path(dir) / required_file
                all_files_present &= required_file_path.exists()
                self.main_logger.debug(f'Does {required_file_path} exist ? {required_file_path.exists()}')
            if all_files_present:
                valid_dirs.append(directory)
        return valid_dirs

    # Python program to illustrate the intersection
    # of two lists in most simple way
    # https://www.geeksforgeeks.org/python-intersection-two-lists/
    def intersection(self, a, b):
        return [value for value in a if value in b]

    def module_path(self, module_name: str) -> Path:
        return self.modules_path / module_name

    def available_modes_for_module(self, module_name: str) -> list:
        entries = None
        modes = []
        try:
            entries = os.scandir(self.module_path(module_name))
            for entry in entries:
                if entry.is_file() and entry.name.startswith('module.'):
                    modes.append(entry.name.split('.')[1])
        except Exception as e:
            self.main_logger.error(f'Could not access module {module_name}')
            self.main_logger.error(e)

        return modes

    def best_locale_desc_path_for(self, module_name: str) -> Path:
        module_root_path = self.module_path(module_name)
        # LANG is generally something like
        #  C
        #  en_US.utf8
        #  fr_FR.iso8859-15
        # We only use the part before the '.', so
        # we split at '.' and take the first element
        locale = os.environ['LANG'].split('.')[0]

        # To continue, in the case of fr_FR, to retrieve
        # only "fr", we split at '_' and take the first
        # element
        simple_locale = locale.split('_')[0]

        potential_paths = [
            module_root_path / f'DESC.{locale}',
            module_root_path / f'DESC.{simple_locale}',
            module_root_path / f'DESC']

        for desc_path in potential_paths:
            if desc_path.exists():
                return desc_path

        self.main_logger.error('No Description found')

        return None


    # x86/cli

    def list_modules_renewed(self, modules_path:str):
        modules = {}
        # By order of importance, from generic to specialized
        architectures_dirs = ['any_arch', f'{self.architecture}']
        try:
            entries = os.scandir(modules_path)
        except:
            self.main_logger.error(
                f'Cannot access modules directory {modules_path}.')
            return modules
        dir_names = [Path(entry.name) for entry in entries if entry.is_dir()]

        for module_name in dir_names:
            module_dirpath = Path(modules_path / module_name)
            arch_dirs = self.intersection(
                [entry.name for entry in os.scandir(module_dirpath)],
                architectures_dirs)
            if not arch_dirs:
                self.main_logger.info(f'No support for architecture {self.architecture} in {module_name} : Skipping')
                continue

            modes_dirpaths = {}
            for arch_dirname in arch_dirs:
                arch_dirpath = module_dirpath / arch_dirname

                modules_modes = self.list_dirs(
                    from_dir=arch_dirpath,
                    containing_files=self.REQUIRED_FILES_PATHS)

                available_modes = self.intersection(modules_modes, ["cli", "tui", "gui"])
                for mode in available_modes:
                    modes_dirpaths[mode] = arch_dirpath / mode

            if "cli" in modes_dirpaths:
                modules[module_name] = modes_dirpaths
            else:
                self.main_logger.warning(f'Ignoring module {module_name} (arch: {arch_dirname}) since no valid CLI mode were found')

        return modules

    def list_modules(self) -> list:
        return sorted(self.list_dirs(
            from_dir=self.modules_path,
            containing_files=self.REQUIRED_FILES_PATHS))

    def module_exist(self, module_name: str) -> bool:
        module_path = self.module_path(module_name)
        all_files_present = True

        for file_path in self.REQUIRED_FILES_PATHS:
            all_files_present &= (module_path / file_path).exists()

        return all_files_present

    def module_description(self, module_name: str) -> dict:
        info = {}

        if not self.module_exist(module_name):
            self.main_logger.error(f'Module {module_name} does not exist')
            return info

        desc_file_path = self.best_locale_desc_path_for(module_name)
        if not desc_file_path:
            self.main_logger.error(f'No description found for module {module_name} !')
            return info

        modes = self.available_modes_for_module(module_name)
        # 'module.cli' is mandatory.
        # No modes returned means that 'module.cli' was not found.
        if not modes:
            self.main_logger.error(f'module.cli was not for module {module_name}')
            return info

        # FIXME Deal with errors here
        with open(desc_file_path) as desc_file:
            info['description'] = desc_file.readline()

        info['modes'] = modes

        return info

    def list_modules_with_descriptions(self) -> tuple:
        # FIXME Create an appropriate structure or object
        # Make an array of it and output it
        modules_info = {}
        modules = self.list_modules()

        for module_name in modules:
            info = self.module_description(module_name)
            if not info:
                self.main_logger.error(f'Could not get accurate info about module {module_name}. Skipping...')

            modules_info[module_name] = info

        return modules_info

    def print_modules(self, modules_info: dict = None):
        if not modules_info:
            modules_info = self.list_modules_with_descriptions()

        for module_name in modules_info:
            info = modules_info[module_name]
            print(f'\t{module_name}\t{info["modes"]}\t{info["description"]}')


    def system_can_handle_gui(self):
        return "DISPLAY" in os.environ

    def execute_module(self, module_name: str, arguments: list):
        info = self.module_description(module_name)
        # FIXME Check if TUI or GUI can actually be run !
        # If no display is available, and the console is not
        # interactive, there's no way to execute GUI or TUI !
        mode = 'cli'
        if not arguments:
            if 'gui' in info['modes'] and self.system_can_handle_gui():
                mode = 'gui'
            elif 'tui' in info['modes']:
                mode = 'tui'

        subprocess.run([self.module_path(module_name) / f'module.{mode}'] + arguments)

if __name__ == '__main__':

    def command(*command_line):
        return subprocess.check_output(command_line).decode().strip()

    architecture = command('uname', '-i').lower()
    if architecture == 'unknown':
        architecture = command('uname', '-m')

    distribution = ''
    try:
        lsb_release_output = command('lsb_release', '-i').lower()
        if 'debian' in lsb_release_output:
            distribution = 'debian'
        elif 'ubuntu' in lsb_release_output:
            distribution = 'ubuntu'
        else:
            distribution = lsb_release_output
    except:
        print('Cannot determine distribution')

    arguments = sys.argv
    configurator = Configurator(
        architecture=architecture,
        distribution=distribution,
        modules_path='/usr/share/armbian/configurator/modules')
    n_args = len(arguments)
    if n_args < 2:
        configurator.print_modules()
    else:
        module_name = arguments[1]
        configurator.execute_module(module_name, arguments=arguments[2:])
